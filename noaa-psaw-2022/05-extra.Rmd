---
title: "Troubleshooting, other packages, tips and tricks"
subtitle: "NOAA PSAW Seminar Series"
author: ""
institute: ""
date: "2022-03-02"
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "theme.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
---

<!-- Previous slides: https://www.dropbox.com/s/gu43n4gvqmo0uzy/sdmTMB-intro-2021.pdf?dl=1 -->
<!-- Build with: xaringan::inf_mr() -->

```{r preamble, include=FALSE, cache=FALSE}
source(here::here("noaa-psaw-2022/preamble.R"))
do.call(knitr::opts_chunk$set, knitr_opts)
```

```{r libs, include=FALSE}
library(sdmTMB)
```

---

# Getting help

* sdmTMB GitHub repository:  
  <https://github.com/pbs-assess/sdmTMB>
  
* sdmTMB documentation:  
  <https://pbs-assess.github.io/sdmTMB/index.html>

*  New features to suggest? Bugs?  
  <https://github.com/pbs-assess/sdmTMB/issues>

---

# Related modelling software

.center[
<img src="images/table_comparison.png" width="550px" height = "500px"/>
]
<!-- --- -->

<!-- # SPDE approach / INLA / etc; comparison with other software -->

<!-- --- -->

<!-- # Fitting basic spatial models in sdmTMB (Philina) -->

<!-- * Making meshes … link to INLA tutorial (+interactive meshbuilder) -->
<!-- * How do you know your model hasn’t converged? Who is Hessian and why hasn’t he converged? -->
<!-- * What warnings do you need to worry about?  -->
<!-- * Overall magnitude of errors / observation error etc.  -->

---

class: center, middle, inverse

# Troubleshooting

---

# Example of non-converging model

.small[
```{r pcod-spatial-rf, echo=TRUE, eval=TRUE, warning=FALSE}
mesh <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 10)

fit <- sdmTMB(
  present ~ depth * year,
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"
)
```

```r
#> Warning message:
#> The model may not have converged: 
#> non-positive-definite Hessian matrix. 
```
]
---

# Who is Hessian and why are they not "positive definite"?

* A Hessian matrix is a matrix of second derivatives of a function (here the negative log likelihoood surface)

--

* The inverse of the negative Hessian is the covariance matrix

--

* Warning means the curvature of the negative log-likelihood surface is inconsistent with the model having found the best fit.

--

* Overparameterized? Variance estimated near zero?

--

* See [vignette("troubleshooting", "glmmTMB")](https://cran.r-project.org/web/packages/glmmTMB/vignettes/troubleshooting.html)

---

# Inspecting output

One or more standard errors being `NaN` is a problem:

.small[
```{r, echo=TRUE, highlight.output=10}
fit
```
]

---

# Inspecting output

We could also look directly at the TMB `sdreport`:

.small[
```{r, echo=TRUE, highlight.output=c(6, 9, 10, 11)}
fit$sd_report
```
]

---

# Looking at gradients

Log likelihood gradient with respect to fixed effects:

.small[
```{r, echo=TRUE}
max(fit$gradients)
```
]

* Gradient becomes smaller as likelihood surface becomes flatter at the location in parameter space

--

* Flatter surface = closer to point of maximum likelihood

--

* So, small values are consistent with convergence (no hard rule, perhaps at least < 0.001)

---

# Interpretation

* Linear interaction term seems tricky to estimate

* Solutions:
  * make sure the model is identifiable
  * drop linear interaction (maybe not important)
  * try re-scaling predictors
  * try a different mesh setup
  * simplify some other part of the model
  * try a related fixed-effect structure, e.g., non-linear smooths
  
---

# Smooth effects by year

Separate smooths by year:

```{r eval = FALSE, echo=TRUE}
pcod$fyear <- as.factor(pcod$year)
fit <- sdmTMB(
  present ~ s(depth, by = fyear), #<<
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"
)
```

---

# 2D smooth effects

year x depth as smooth interaction:

```{r eval = FALSE, echo=TRUE}
fit <- sdmTMB(
  present ~ s(depth, by = year), #<<
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"
)
```

---
 
# Other warning messages / diagnostics

* `Matrix` package, compiler warnings
  * generally OK, but see glmmTMB page:  
    <https://glmmtmb.github.io/glmmTMB/>

* TMB users forum  
  <https://groups.google.com/g/tmb-users/>  

---

# Words of wisdom

**Start simple!**

* These are complex models:
  * They may take a while to fit
  * Easy to create configurations that won't converge
  * Can also be hard to wrap your head around

---

# Words of wisdom

Options for starting simple:
  * start intercept only
  * start with a spatial not spatiotemporal model
  * start without random fields:  
    `spatial = 'off', spatiotemporal = 'off'`
  * start with coarse meshes, maybe increase later  
    (*mesh resolution greatly impacts speed*)

---

# More words of wisdom


--

* Make lots of plots

--

* Don't get too caught up in model configuration

--

* Work in constant distance coordinates (e.g., UTMs)

--

* Consider the scale of the response and predictors

--

* Try other approaches: will a similar model converge in `mgcv`?

--

* Is observation error variance >> process variance?  
  Known to be problematic for state-space models.
  
---

# Large observation error looks like noise

* $\sigma_{obs}$ >> $\sigma_{O}$, $\sigma_{E}$

```{r sim-rf-large_phi, echo=FALSE, fig.asp=0.5}
set.seed(123)
predictor_dat <- data.frame(
  X = runif(300), Y = runif(300),
  year = 1
)
mesh <- make_mesh(predictor_dat,
  xy_cols = c("X", "Y"),
  cutoff = 0.1
)

sim_dat <- sdmTMB_simulate(
  formula = ~1,
  data = predictor_dat,
  time = "year",
  mesh = mesh,
  family = gaussian(link = "identity"),
  range = 0.5,
  sigma_E = 0.1,
  phi = 1.0,
  sigma_O = 0.1,
  seed = 3542,
  B = c(0.2) # B0 = intercept
)

ggplot(sim_dat, aes(X, Y, col = observed)) +
  geom_point()
```
 
---
  
# Moderate observation errors

* $\sigma_{obs}$ = $\sigma_{O}$ = $\sigma_{E}$
    
```{r sim-rf-med_phi, echo = FALSE, fig.asp=0.5}
set.seed(123)
sim_dat <- sdmTMB_simulate(
  formula = ~1,
  data = predictor_dat,
  time = "year",
  mesh = mesh,
  family = gaussian(link = "identity"),
  range = 0.5,
  sigma_E = 0.1,
  phi = 0.1,
  sigma_O = 0.1,
  seed = 3542,
  B = c(0.2) # B0 = intercept
)

ggplot(sim_dat, aes(X, Y, col = observed)) +
  geom_point()
```
  
  
---
     
# Small observation errors  
    
* $\sigma_{obs}$ << $\sigma_{O}$, $\sigma_{E}$
    
```{r sim-rf-small_phi, echo = FALSE, fig.asp=0.5}
set.seed(123)
sim_dat <- sdmTMB_sim2(
  formula = ~1,
  data = predictor_dat,
  time = "year",
  mesh = mesh,
  family = gaussian(link = "identity"),
  range = 0.5,
  sigma_E = 0.1,
  phi = 0.01,
  sigma_O = 0.1,
  seed = 3542,
  B = c(0.2) # B0 = intercept
)

ggplot(sim_dat, aes(X, Y, col = observed)) +
  geom_point()
```
  
---

# Lots of topics not covered today

* Simulation
* Residuals
* Time-varying coefficients
* Spatially varying coefficients
* Interpolation over missing years
* Forecasting on future years
* Penalties/priors
* Cross validation
* Bayesian sampling with Stan
* Correlation boundaries

---

# Lots of topics not covered today

* Simulation | `sdmTMB_simulate()`
* Residuals | `residuals()`, `dharma_residuals()`
* Time-varying coefficients | `time_varying = ...`
* Spatially varying slopes | `spatial_varying = ...`
* Interpolation over missing years | `extra_time`
* Forecasting on future years | `extra_time`
* Penalties/priors | `sdmTMB_priors()`
* Cross validation | `sdmTMB_cv()`
* Bayesian sampling with Stan | `extract_mcmc()`
* Correlation boundaries | `add_barrier_mesh()`
