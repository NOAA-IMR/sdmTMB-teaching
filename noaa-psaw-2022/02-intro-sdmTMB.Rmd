---
title: "Introduction to sdmTMB"
subtitle: "NOAA PSAW Seminar Series"
author: "Names Here"
institute: ""
date: "2022-03-02"
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "theme.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
---

<!-- Previous slides: https://www.dropbox.com/s/gu43n4gvqmo0uzy/sdmTMB-intro-2021.pdf?dl=1 -->

<!-- Build with: xaringan::inf_mr() -->

```{r options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  dpi = 300,
  out.width = "700px",
  fig.asp = 1/1.618,
  cache = TRUE,
  autodep = TRUE,
  cache.comments = TRUE,
  fig.align = "center",
  echo = FALSE
)
```

```{r style, include=FALSE, cache=FALSE}
source(here::here("noaa-psaw-2022/preamble.R"))
```

```{r libs, include=FALSE}
library(dplyr)
library(sdmTMB)
library(ggplot2)
theme_set(theme_light())
```

---

class: center, middle, inverse

# A gentle(?) introduction to sdmTMB

---

# sdmTMB origins

* A need for reproducible code and methods for assessments [(Anderson et al. 2019)](https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2019/2019_041-eng.html)

.center[
<img src="images/yellowtail_synopsis.png" width="450px" height = "400px"/>
]

---

# sdmTMB highlights

* sdmTMB is a user-friendly R package for modeling spatial processes. 
  * Familiar syntax to widely used functions/packages; `glm()`, mgcv, glmmTMB, etc.
  
  * Performs fast (marginal) maximum likelihood estimation via TMB
  
  * Widely applicable to many stock assessments, bycatch models, etc. that include spatially referenced data

---

# sdmTMB limitations

* sdmTMB fits a variety of models with univariate responses

* sdmTMB: 
  * does not fit multivariate models ([see VAST](https://github.com/James-Thorson-NOAA/VAST))
  * does not conduct spatial (dynamic) factor analysis ([see VAST](https://github.com/James-Thorson-NOAA/VAST))
  * doesn't have built-in delta/hurdle or zero-inflated models (but these can be fit as two parts) 

---

# sdmTMB workflow

<img src="images/sdmTMB_workflow.png" height = "500px" width="900px" />

---

class: center, middle, inverse

# Syntax: formulas for non-spatial model components

---

# Formula interface

* sdmTMB uses a similar formula interface to widely used R packages  

* A formula is used to specify fixed effects and (optionally) random intercepts

.small[
```{r formulas1, echo=TRUE, eval=FALSE}
# linear effect of x1:
formula = y ~ x1 

# add smoother effect of x2:
formula = y ~ x1 + s(x2)

# add random intercept by group g:
formula = y ~ x1 + s(x2) + (1 | g)
```
]

---

# Smoothers (as in mgcv)

.small[
```{r formulas-smoothers, echo=TRUE, eval=FALSE}
# smoother effect of x:
formula = y ~ s(x)

# basis dimension of 5:
formula = y ~ s(x, k = 5)

# bivariate smoother effect of x & y:
formula = y ~ s(x, y)

# smoother effect of x1 varying by x2:
formula = y ~ s(x1, by = x2)

# other kinds of mgcv smoothers:
formula = ~ s(month, bs = "cc", k = 12)
```

* Smoothers are penalized ('p-splines'), i.e. data determine 'wiggliness'
]

---

# Other common R formula options

```{r formulas-other, echo=TRUE, eval=FALSE}
# transformations using `I()` notation
y ~ depth + I(depth^2)

# polynomial functions using `poly` 
y ~ poly(depth, degree = 2)

# omit intercept
y ~ -1 + as.factor(year)
y ~ 0 + as.factor(year)
```

---

# Breakpoint functions for threshold analyses

```{r breakpt, echo=TRUE, eval=FALSE}
cpue ~ breakpt(temperature)
```

```{r make-breakpt, out.width='500px', fig.width=5}
df <- data.frame(x = seq(1, 100))
slope <- 0.1
df$y <- ifelse(df$x < 50, slope * df$x, slope * 50)
ggplot(df, aes(x, y)) +
  geom_line(col = "blue") +
  xlab("Temperature") +
  ylab("CPUE") +
  ggtitle("Breakpoint function")
```

---

# Logistic functions for threshold analyses

```{r logistic, echo=TRUE, eval=FALSE}
cpue ~ logistic(temperature)
```

```{r make-logistic, out.width='500px', fig.width=5}
df <- data.frame(x = seq(1, 100))
slope <- 0.1
df$y <- 3.0 / (1 + exp(-0.1 * (df$x - 50)))
ggplot(df, aes(x, y)) +
  geom_line(col = "blue") +
  xlab("Temperature") +
  ylab("CPUE") +
  ggtitle("Logistic function")
```


---

class: center, middle, inverse

# Syntax: families and links

---

# Families

* Many of the same families used in `glm()`, `glmmTMB()`, `mgcv::gam()` can be
  used here:

* Includes: `gaussian()`, `Gamma()`, `binomial()`, `poisson()`, `Beta()`, 
  `student()`, `tweedie()`, `truncated_nbinom1()`, `truncated_nbinom2()`,
  `nbinom1()`, `nbinom2()`
  
* All have `link` arguments
  
* See `?sdmTMB::Families`

---

# An aside on the Tweedie

.small[
* Useful for positive continuous data with zeros (e.g., biomass density per unit effort) 

* Dispersion ( $\phi$ ) and power ( $p$ ) parameters allow for a wide variety of shapes including many zeros

* Also known as compound Poisson-Gamma distribution
]

```{r sim-tweedie, fig.width=4, out.width='400px'}
set.seed(123)
r1 <- fishMod::rTweedie(20000, mu = 3, phi = 0.1, p = 1.3)
r2 <- fishMod::rTweedie(20000, mu = 3, phi = 1.5, p = 1.3)
df <- data.frame(y = c(r1, r2), phi = sort(rep(c("0.1", "1.5"), length(r1))))
df$phi <- paste("Dispersion (phi) =", df$phi)
ggplot(df, aes(y)) +
  geom_histogram(bins = 200) +
  ylab("Density") +
  facet_wrap(~phi, ncol = 1, scale = "free_y") +
  coord_cartesian(xlim = c(0, 20))
```

---

class: center, middle, inverse

# Syntax: spatial model components

---

# Spatial vs. spatiotemporal fields

* A spatial field can be thought of as an intercept—common across all time slices 
  * a wiggly spatial process that is constant in time

* Spatiotemporal variation represents separate fields estimated for each time
  slice (possibly correlated)
  * wiggly spatial processes that change through time

* Refer to vignette for math notation
---

# Spatial fields can be turned on / off

* By default `sdmTMB()` estimates a spatial field  

```{r echo=TRUE, eval=FALSE}
fit <- sdmTMB(
  cpue ~ depth + offset,
  family = gaussian(),
  data = dat,
  spatial = TRUE,
  ...
)
```

---

# Why *not* estimate a spatial field?

* If shared process across time slices isn't of interest

* If magnitude of spatiotemporal variability >> spatial variation

* If confounded with other parameters (more later)

---

# Spatiotemporal fields can be turned on / off

* By default `sdmTMB()` estimates a spatiotemporal field if the `time` argument is specified

```{r echo=TRUE, eval=FALSE}
fit <- sdmTMB(
  cpue ~ depth + offset,
  family = gaussian(),
  data = dat,
  spatiotemporal = "iid",
  ...
)
```

---

# Types of spatiotemporal fields

* None (`spatiotemporal = "off"`)

* Independent (`spatiotemporal = "iid"`)

* Random walk (`spatiotemporal = "rw"`)

* Autoregressive (`spatiotemporal = "ar1"`)

---

# Spatiotemporal fields

* Why include spatiotemporal fields?
  * If there are 'latent' spatial processes that vary through time
  * E.g., effect of water temperature on abundance if temperature wasn't in the model
  * Represents all the missing variables that vary through time

* Why would a field be IID vs RW/AR1?
  * Do we expect hotspots to be independent with each time slice or adapt slowly over time?

---

class: center, middle, inverse

# A basic spatial example

---

# The Pacific Cod dataset

.medium[
```{r, echo=TRUE}
library(dplyr)
library(ggplot2)
library(sdmTMB)
pcod %>% 
  select(year, X, Y, depth, density, present) %>% 
  head()
```
]

---

# Fitting a basic GLM

.tiny[
```{r pcod-glm, echo=TRUE}
fit_glm <- glm(
  present ~ 1,
  data = pcod,
  family = binomial(link = "logit")
)

mesh <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 10)
fit <- sdmTMB(
  present ~ 1,
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "off"
)
```
]

---

# SPDE approach / INLA / etc; comparison with other software

<!-- --- -->

<!-- # Fitting basic spatial models in sdmTMB (Philina) -->

<!-- * Making meshes … link to INLA tutorial (+interactive meshbuilder) -->
<!-- * How do you know your model hasn’t converged? Who is Hessian and why hasn’t he converged? -->
<!-- * What warnings do you need to worry about?  -->
<!-- * Overall magnitude of errors / observation error etc.  -->

---

class: center, middle, inverse

# Troubleshooting

---

# Who is Hessian and why are they not "positive definite"??

* A Hessian matrix is a matrix of second derivatives of a function (here the negative log likelihoood surface)
* The inverse of the negative Hessian is the covariance matrix
* Warning means the curvature of the negative log-likelihood surface is inconsistent with the model having found the best fit.
* Overparameterized? Variance estimated near zero?
* See [vignette("troubleshooting", "glmmTMB")](https://cran.r-project.org/web/packages/glmmTMB/vignettes/troubleshooting.html)

---

# Splines

---

# Spatiotemporal models, different structures

---

# Prediction (prediction in time – e.g. future SDMs, prediction in space – new areas / unsampled areas)

---

# Building a mesh

```{r}
mesh <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 10)
plot(mesh)
```

---

# Adding spatial random fields

```{r pcod-spatial-rf, echo=TRUE}
fit <- sdmTMB(
  present ~ s(depth, k = 5),
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"   #<<
)
```

---

# Inspecting the model output

.small[
```{r, echo=TRUE, highlight.output=c(1)}
summary(fit)
```
]

---

# Inspecting the model output

.small[
```{r, echo=TRUE, highlight.output=2:5}
summary(fit)
```
]

---

# Inspecting the model output

.small[
```{r, echo=TRUE, highlight.output=6:9}
summary(fit)
```
]

---

# Inspecting the model output

.small[
```{r, echo=TRUE, highlight.output=11:13}
summary(fit)
```
]

---

# Extracting parameters in a data frame

```{r, echo=TRUE}
# Main effects:
tidy(fit)

# Variance-related terms:
tidy(fit, effects = "ran_pars")
```

<!-- TODO: sigma_O missing!? -->

---

# Extracting parameters in a data frame

.small[
```{r, echo=TRUE}
tidy(fit, "ran_pars", conf.int = TRUE) %>% 
  as_tibble()
```
]

---

# Making predictions

.small[
```{r, echo=TRUE}
p <- predict(fit)
select(p, X, Y, est:omega_s) %>% 
  glimpse()
```
]

---

# Making predictions

* `est`: Overall estimate **in link space**
* `est_non_rf`: Estimate of non-random-field components
* `est_rf`: Estimate of random-field components
* `omega_s`: Spatial random field

---

# Making predictions on new data


```{r, echo=TRUE}
head(select(qcs_grid, X, Y, depth))
nd <- filter(qcs_grid, year == 2017)
p <- predict(fit, newdata = nd)
```

---

# Plotting predictions on new data

```{r, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = plogis(est))) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_fixed()
```

---

# Plotting main effect contributions

```{r, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = plogis(est_non_rf))) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_fixed()
```

---

# Plotting spatial random effects

```{r, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = omega_s)) +
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed()
```

---

# Plotting depth effect

.xsmall[
```{r pcod-sp-depth-pred, echo=TRUE}
nd <- data.frame(depth = seq(30, 300, length.out = 100))
p <- predict(fit, newdata = nd, se_fit = TRUE, re_form = ~ 0)
```

```{r pcod-sp-depth-pred-plot, fig.width=5, echo=TRUE}
p$lwr <- plogis(p$est - 1.96 * p$est_se)
p$upr <- plogis(p$est + 1.96 * p$est_se)
ggplot(p, aes(nd$depth, plogis(est), ymin = lwr, ymax = upr)) +
  geom_ribbon(alpha = 0.2) +
  geom_line() + xlab("Depth (m)") + ylab("")
```
]

---

# Extending to a spatiotemporal model

The Pacific Cod dataset:

.small[
```{r, echo=TRUE}
pcod %>% 
  select(year, X, Y, depth, density, present) %>% 
  head()
```
]

---

# Our previous spatial model fit

```{r pcod-spatial-rf-reminder, echo=TRUE, eval=FALSE}
fit <- sdmTMB(
  present ~ s(depth, k = 5),
  data = pcod,
  mesh = mesh,
  family = binomial(link = "logit"),
  spatial = "on"
)
```

---

# Switching to density

```{r pcod-spatial-rf-density, echo=TRUE, eval=TRUE}
fit <- sdmTMB(
  density ~ s(depth, k = 5), #<<
  data = pcod,
  mesh = mesh,
  family = tweedie(link = "log"), #<<
  spatial = "on"
)
```

---

# Adding spatiotemporal fields

```{r pcod-st-fit, echo=TRUE, eval=TRUE, results='hide'}
fit <- sdmTMB(
  density ~ s(depth, k = 5) + 0 + as.factor(year), #<<
  data = pcod,
  mesh = mesh,
  family = tweedie(link = "log"),
  spatial = "on",
  time = "year", #<<
  spatiotemporal = "iid", #<<
  silent = FALSE # show progress!
)
```

---

# Inspecting the model fit

.xsmall[
```{r, eval=FALSE, echo=TRUE}
print(fit)
```

```{r pcod-st-print2, echo=TRUE, eval=TRUE}
#> Spatiotemporal model fit by ML ['sdmTMB']
#> Formula: density ~ s(depth, k = 5) + as.factor(year)
#> Time column: "year"
#> Mesh: mesh
#> Data: pcod
#> Family: tweedie(link = 'log')
#>                     coef.est coef.se
#> (Intercept)             1.79    0.29
#> as.factor(year)2004     0.57    0.31 #<<
#> as.factor(year)2005     0.31    0.31 #<<
#> ...
#> 
#> Dispersion parameter: 10.78
#> Tweedie p: 1.49
#> Matern range: 12.85 #<<
#> Spatial SD: 1.81
#> Spatiotemporal SD: 1.78 #<<
#> ML criterion at convergence: 6246.433
```
]

---

# Predicting on the survey grid

```{r pcod-st-pred, echo=TRUE}
p <- predict(fit, newdata = qcs_grid)
```

* `est`: Overall estimate **in link space**
* `est_non_rf`: Estimate of non-random-field components
* `est_rf`: Estimate of random-field components
* `omega_s`: Spatial random field
* `epsilon_st`: **Spatiotemporal random field**

---

# Plotting overall predictions

.small[
```{r pcod-st-plot-est, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = exp(est))) +
  geom_raster() +
  scale_fill_viridis_c(trans = "sqrt") +
  facet_wrap(~year) +
  coord_fixed()
```
]

---

# Plotting main effect contributions

.small[
```{r pcod-st-plot-non-rf, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = exp(est_non_rf))) +
  geom_raster() +
  scale_fill_viridis_c(trans = "sqrt") +
  facet_wrap(~year) +
  coord_fixed()
```
]

---

# Plotting spatial random effects

.small[
```{r pcod-st-plot-omega, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = omega_s)) +
  geom_raster() +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  coord_fixed()
```
]

---

# Plotting spatiotemporal random effects

.small[
```{r pcod-st-plot-eps, echo=TRUE, fig.width=7}
ggplot(p, aes(X, Y, fill = epsilon_st)) +
  geom_raster() +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  coord_fixed()
```
]

---

# Getting help

---
