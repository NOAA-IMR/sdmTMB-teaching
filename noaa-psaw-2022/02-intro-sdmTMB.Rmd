---
title: "Introduction to sdmTMB"
subtitle: "NOAA PSAW Seminar Series"
author: ""
institute: ""
date: ""
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "theme.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
---

<!-- Build with: xaringan::inf_mr() -->

```{r preamble, include=FALSE, cache=FALSE}
source(here::here("noaa-psaw-2022/preamble.R"))
do.call(knitr::opts_chunk$set, knitr_opts)
```

```{r libs, include=FALSE}
library(dplyr)
library(sdmTMB)
library(ggplot2)
```

# sdmTMB origins

A need for reproducible code and methods for assessments [(Anderson et al. 2019)](https://www.dfo-mpo.gc.ca/csas-sccs/Publications/ResDocs-DocRech/2019/2019_041-eng.html)

.center[
<img src="images/yellowtail_synopsis.png" width="450px" height = "400px"/>
]

---

# sdmTMB highlights

sdmTMB is a user-friendly R package for modeling spatial processes

* Familiar syntax to widely used functions/packages; `glm()`, mgcv, glmmTMB, etc.
  
* Performs fast (marginal) maximum likelihood estimation via TMB
  
* Widely applicable to many stock assessments, bycatch models, etc. that include spatially referenced data

---

# sdmTMB limitations

sdmTMB fits a variety of models with univariate responses

sdmTMB: 
* does not fit multivariate models ([see VAST](https://github.com/James-Thorson-NOAA/VAST))
* does not conduct spatial (dynamic) factor analysis ([see VAST](https://github.com/James-Thorson-NOAA/VAST))
* doesn't have built-in delta/hurdle or zero-inflated models (but these can be fit as two parts) 

---

# Installing sdmTMB

Currently:

* Install a C++ compiler
  * e.g., [Rtools](https://cran.r-project.org/bin/windows/Rtools/rtools40.html) on Windows
  * e.g., Xcode command line tools on a Mac:  
  `xcode-select --install`

.small[
```{r, eval=FALSE, echo=TRUE}
# install.packages("remotes")
remotes::install_github("pbs-assess/sdmTMB", 
  dependencies = TRUE)
```
]

Should be on CRAN very soon so the C++ compiler won't be necessary.

---

# Installing sdmTMB

Warning: The INLA package is large, not on CRAN, and can be slow to install. If you run into problems, try installing it separately first:

<https://www.r-inla.org/download-install>

---

# sdmTMB workflow

1. Prepare data .xsmall[(convert to UTMs, scale covariates, ...)]

2. Construct a mesh

3. Fit the model

4. Inspect the model .xsmall[(and possibly refit the model)]

5. Predict from the model

6. Calculate any derived quantities

---

# sdmTMB workflow

1. Prepare data: .blue[`add_utm_columns()`]

2. Construct a mesh: .blue[`make_mesh()`]

3. Fit the model: .blue[`sdmTMB()`]

4. Inspect the model: .blue[`print()`], .blue[`tidy()`], .blue[`residuals()`]

5. Predict from the model: .blue[`predict()`]

6. Get derived quantities: .blue[`get_index()`], .blue[`get_cog()`]

<!-- <img src="images/sdmTMB_workflow.png" height = "500px" width="900px" /> -->

---

class: center, middle, inverse

# Preparing data: getting into constant distance coordinates

---

# Getting into UTMs

Need a projection that preserves constant distance

UTMs work well for regional analyses

Helper function: `sdmTMB::add_utm_columns()`

Internally, guesses at UTM zone and uses the sf package:  
`sf::st_as_sf()`, `sf::st_transform()`, and `sf::st_coordinates()`

Or use the sf or sp packages yourself

---

# Example of adding UTM columns

```{r, echo=TRUE, message=TRUE}
d <- data.frame(
  lat = c(52.1, 53.4), 
  lon = c(-130.0, -131.4)
)
d <- sdmTMB::add_utm_columns(d, c("lon", "lat"))
d
```

* Note default `units = "km"`
* Why? Range parameter estimated in units of X and Y
* Should be not too big or small for estimation

---

class: center, middle, inverse

# Constructing a mesh

---

# Constructing a mesh

`make_mesh()` has 2 shortcuts to mesh construction

1. K-means algorithm: used to cluster points (e.g., `n_knots = 100`); approach taken in VAST; sensitive to random `seed` argument!

2. Cutoff: minimum allowed distance between vertices (e.g., `cutoff = 10`)
  
Alternatively, build any INLA mesh and supply it to the `mesh` argument in `make_mesh()`

---

# Constructing a mesh

.small[
Size of mesh has the single largest impact on fitting speed

`cutoff` is in units of x and y (minimum triangle size)
]

.small[
```{r make-mesh, echo=TRUE, fig.asp=1, out.width='280px', fig.width=5.5}
d <- data.frame(x = runif(500), y = runif(500))
mesh <- make_mesh(d, xy_cols = c("x", "y"), cutoff = 0.1)
mesh$mesh$n
plot(mesh)
```
]

---

class: center, middle, inverse

# Fitting the model: sdmTMB()

---

# sdmTMB()

Set up similarly to glmmTMB(). Common arguments:

```r
fit <- sdmTMB(
  formula,
  data,
  mesh,
  time = NULL,
  family = gaussian(link = "identity"),
  spatial = c("on", "off"),
  spatiotemporal = c("IID", "AR1", "RW", "off"),
  silent = TRUE,
  ...
)
```

See `?sdmTMB`

---

class: center, middle, inverse

# Syntax: formulas for non-spatial model components

---

# Formula interface

sdmTMB uses a similar formula interface to widely used R packages  

A formula is used to specify fixed effects and (optionally) random intercepts

.small[
```{r formulas1, echo=TRUE, eval=FALSE}
# linear effect of x1:
formula = y ~ x1

# add smoother effect of x2:
formula = y ~ x1 + s(x2)

# add random intercept by group g:
formula = y ~ x1 + s(x2) + (1 | g)
```
]

---

# Smoothers (as in mgcv)

.small[
```{r formulas-smoothers, echo=TRUE, eval=FALSE}
# smoother effect of x:
formula = y ~ s(x)

# basis dimension of 5:
formula = y ~ s(x, k = 5)

# bivariate smoother effect of x & y:
formula = y ~ s(x, y)

# smoother effect of x1 varying by x2:
formula = y ~ s(x1, by = x2)

# other kinds of mgcv smoothers:
formula = ~ s(month, bs = "cc", k = 12)
```

Smoothers are penalized ('p-splines'), i.e. data determine 'wiggliness'
]

---

# Other common R formula options

Polynomials and omitting the intercept:

```{r formulas-other, echo=TRUE, eval=FALSE}
# transformations using `I()` notation
y ~ depth + I(depth^2)

# polynomial functions using `poly`
y ~ poly(depth, degree = 2)

# omit intercept
y ~ -1 + as.factor(year)
y ~ 0 + as.factor(year)
```

---

# Breakpoint functions for threshold analyses

```{r breakpt, echo=TRUE, eval=FALSE}
cpue ~ breakpt(temperature)
```

```{r make-breakpt, out.width='500px', fig.width=5}
df <- data.frame(x = seq(1, 100))
slope <- 0.1
df$y <- ifelse(df$x < 50, slope * df$x, slope * 50)
ggplot(df, aes(x, y)) +
  geom_line(col = "blue") +
  xlab("Temperature") +
  ylab("CPUE") +
  ggtitle("Breakpoint function")
```

---

# Logistic functions for threshold analyses

```{r logistic, echo=TRUE, eval=FALSE}
cpue ~ logistic(temperature)
```

```{r make-logistic, out.width='500px', fig.width=5}
df <- data.frame(x = seq(1, 100))
slope <- 0.1
df$y <- 3.0 / (1 + exp(-0.1 * (df$x - 50)))
ggplot(df, aes(x, y)) +
  geom_line(col = "blue") +
  xlab("Temperature") +
  ylab("CPUE") +
  ggtitle("Logistic function")
```

---

class: center, middle, inverse

# Syntax: families and links

---

# Families

Many of the same families used in `glm()`, `glmmTMB()`, `mgcv::gam()` can be used here

Includes:
  `gaussian()`, `Gamma()`, 
  `binomial()`, `poisson()`, `Beta()`, 
  `student()`, `tweedie()`, 
  `nbinom1()`, `nbinom2()`,
  `truncated_nbinom1()`, `truncated_nbinom2()`
  
All have `link` arguments
  
See `?sdmTMB::Families`

---

# An aside on the Tweedie

.small[
Useful for positive continuous data with zeros (e.g., biomass density per unit effort) 

Dispersion ( $\phi$ ) and power ( $p$ ) parameters allow for a wide variety of shapes including many zeros

Also known as compound Poisson-Gamma distribution
]

```{r sim-tweedie, fig.width=4, out.width='400px'}
set.seed(123)
r1 <- fishMod::rTweedie(20000, mu = 3, phi = 0.1, p = 1.3)
r2 <- fishMod::rTweedie(20000, mu = 3, phi = 1.5, p = 1.3)
df <- data.frame(y = c(r1, r2), phi = sort(rep(c("0.1", "1.5"), length(r1))))
df$phi <- paste("Dispersion (phi) =", df$phi)
ggplot(df, aes(y)) +
  geom_histogram(bins = 200) +
  ylab("Density") +
  facet_wrap(~phi, ncol = 1, scale = "free_y") +
  coord_cartesian(xlim = c(0, 20))
```

---

class: center, middle, inverse

# Syntax: spatial model components

---

# Spatial vs. spatiotemporal fields

* A spatial field can be thought of as a spatial intercept

  * a wiggly spatial process that is constant in time
  
--

* Spatiotemporal variation represents separate fields estimated for each time
  slice (possibly correlated)
  
  * wiggly spatial processes that change through time

--

* Refer to [model description](https://pbs-assess.github.io/sdmTMB/articles/model-description.html) vignette for math notation

---

# Spatial fields can be turned on/off

* By default `sdmTMB()` estimates a spatial field  

```{r echo=TRUE, eval=FALSE}
fit <- sdmTMB(
  y ~ x,
  family = gaussian(),
  data = dat,
  spatial = "on", #<<
  ...
)
```

---

# Why *not* estimate a spatial field?

* If shared process across time slices isn't of interest

* If magnitude of spatiotemporal variability >> spatial variation

* If confounded with other parameters (more later)

---

# Spatiotemporal fields can be turned on/off

* By default `sdmTMB()` estimates a spatiotemporal field if the `time` argument is specified

```{r echo=TRUE, eval=FALSE}
fit <- sdmTMB(
  y ~ x,
  family = gaussian(),
  data = dat,
  time = "year", # column in `data` #<<
  spatiotemporal = "iid", #<<
  ...
)
```

---

# Types of spatiotemporal fields

* None (`spatiotemporal = "off"`)

* Independent (`spatiotemporal = "iid"`)

* Random walk (`spatiotemporal = "rw"`)

* Autoregressive (`spatiotemporal = "ar1"`)

---

# Independent (IID) spatiotemporal fields

```{r iid-demo}
predictor_dat <- expand.grid(
  x = seq(0, 1, length.out = 100),
  y = seq(0, 1, length.out = 100),
  year = seq_len(6)
)
mesh <- make_mesh(predictor_dat, xy_cols = c("x", "y"), cutoff = 0.05)
sim_dat <- sdmTMB_simulate(
  formula = ~ 1,
  data = predictor_dat,
  time = "year",
  mesh = mesh,
  family = gaussian(),
  range = 0.5,
  sigma_E = 0.2,
  phi = 0.1,
  sigma_O = NULL,
  seed = 1,
  B = 0
)
ggplot(sim_dat, aes(x, y, fill = mu)) +
  facet_wrap(vars(year)) +
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed(expand = FALSE) +
  guides(fill = "none")
```

---

# AR1 spatiotemporal fields

```{r ar1-demo}
sim_dat <- sdmTMB_simulate(
  formula = ~ 1,
  data = predictor_dat,
  time = "year",
  mesh = mesh,
  family = gaussian(),
  range = 0.5,
  sigma_E = 0.2,
  rho = 0.75,
  phi = 0.1,
  sigma_O = NULL,
  seed = 1,
  B = 0
)
ggplot(sim_dat, aes(x, y, fill = mu)) +
  facet_wrap(vars(year)) +
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed(expand = FALSE) +
  guides(fill = "none")
```

.small[Random walk = AR1 with 1.0 correlation]

---

# Spatiotemporal fields

* Why include spatiotemporal fields?

  * If there are 'latent' spatial processes that vary through time
  * E.g., effect of water temperature on abundance if temperature wasn't in the model
  * Represents all the missing variables that vary through time

--

* Why would a field be IID vs RW/AR1?

  * Do we expect hotspots to be independent with each time slice or adapt slowly over time?

---

# After model fitting

Covered in examples that follow:

* `predict()`: `?predict.sdmTMB`
* `residuals()`: `?residuals.sdmTMB`
* `print()`
* `tidy()`: `?tidy.sdmTMB`
* `get_index()`
*  `...`

