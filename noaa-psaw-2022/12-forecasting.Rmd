---
title: "Forecasting with sdmTMB"
subtitle: "NOAA PSAW Seminar Series"
author: ""
institute: ""
date: "March 9, 2022"
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "theme.css"]
    lib_dir: libs
    nature:
      highlightLines: true
      countIncrementalSlides: false
---

<!-- Build with: xaringan::inf_mr() -->

```{r preamble, include=FALSE, cache=FALSE}
source(here::here("noaa-psaw-2022/preamble.R"))
do.call(knitr::opts_chunk$set, knitr_opts)
```

```{r libs, include=FALSE}
library(dplyr)
library(sdmTMB)
library(ggplot2)
```

# Types of forecasting we might be interested in 

* Forecasting in time  
  * missed survey year (interpolating or for AR1/RW estimation)
  * future year
  
* Forecasting in space
  * unsampled area (MPA, area beyond existing domain)

---

# Predicting to missing / future years

* Need a model for time: e.g., can't predict with years as factors

* Options: 
  * Smooth over year, time-varying intercept, AR(1) fields, or ignore year

---

# AR1 spatiotemporal field

```{r pcod-mesh}
mesh <- make_mesh(pcod, c("X", "Y"), cutoff = 15)
```

.small[
```{r fit-ar1, echo=TRUE, eval=TRUE, results='hide'}
# missing and forecasted years:
extra_years <- c(2006, 2008, 2010, 2012, 2014, 2016, 
  2018:2022)
fit_ar1rf <- sdmTMB(
  density ~ depth_scaled + depth_scaled2,
  time = "year",
  extra_time = extra_years, #<<
  spatiotemporal = "AR1", #<<
  data = pcod,
  mesh = mesh,
  family = tweedie(link = "log"),
  spatial = "off",
  silent = FALSE
)
```
]

---

# AR(1) spatiotemporal fields evolve towards mean

```{r pred-ar1-plot-eps}
one_yr <- dplyr::filter(qcs_grid, year == 2017)
grid <- purrr::map_dfr(unique(fit_ar1rf$data$year), function(i) {
  one_yr$year <- i
  one_yr
})
p_ar1 <- predict(fit_ar1rf, newdata = grid)
ggplot(p_ar1, aes(X, Y, fill = epsilon_st)) +
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_gradient2() +
  coord_fixed()
```

---

# Spatiotemporal fields uncertainty grows

```{r eps-se}
eps_est <- predict(fit_ar1rf, newdata = grid, nsim = 200, sims_var = "proj_re_st_vector")
grid$se <- apply(eps_est, 1, sd)
ggplot(grid, aes(X, Y, fill = se)) +
  geom_raster() +
  facet_wrap(~year) +
  coord_fixed()
```

---

# Population index uncertainty baloons

```{r sm-sims}
p_ar1_sims <- predict(fit_ar1rf, newdata = grid, nsim = 400)
ind_ar1 <- get_index_sims(p_ar1_sims)
```

```{r plot-ind-ar1-sm, fig.asp=0.5}
ind_ar1 %>% ggplot(aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.1, colour = NA) +
  geom_vline(xintercept = unique(pcod$year), lty = 2, alpha = 0.2) +
  theme(panel.grid = element_blank())
```

---

# Smoother on year option

.small[
```{r fit-sm, echo=TRUE, eval=TRUE, results='hide'}
# missing and forecasted years:
extra_years <- c(2006, 2008, 2010, 2012, 2014, 2016, 
  2018:2022)
fit_sm <- sdmTMB(
  density ~ s(year) + depth_scaled + depth_scaled2, #<<
  time = "year",
  extra_time = extra_years, #<<
  spatiotemporal = "IID", #<<
  data = pcod,
  mesh = mesh,
  family = tweedie(link = "log"),
  spatial = "on",
  silent = FALSE
)
```
]

---

# Index comparison

* Smoother continues trajectory; AR(1) field reverts towards mean

* A more flexible interface for forecasting is forthcoming

```{r ar1-sims}
p_sm_sims <- predict(fit_sm, newdata = grid, nsim = 400)
ind_sm <- get_index_sims(p_sm_sims)
```

```{r plot-ind-ar1, fig.asp=0.5}
fitted_years <- unique(pcod$year)
bind_rows(
  mutate(ind_ar1, type = "AR(1) fields"),
  mutate(ind_sm, type = "s(year)")
) %>% 
  ggplot(aes(year, est, colour = type, fill = type)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.1, colour = NA) +
  geom_vline(xintercept = fitted_years, lty = 2, alpha = 0.2) +
  theme(panel.grid = element_blank()) +
  coord_cartesian(ylim = c(0, max(ind_ar1$upr) * 1.5)) +
  ylab("Relative biomass index")
```

---

# Spatial forecasting / predicting to new areas

* Previously explored BEI tree dataset  

```{r bei, echo=FALSE, eval=TRUE}
dat <- data.frame(
  x = spatstat.data::bei$x,
  y = spatstat.data::bei$y
)
ggplot(dat, aes(x, y)) +
  geom_point(col = "darkblue", alpha = 0.1) +
  coord_cartesian(expand = FALSE)
```

---

# Mesh more uncertain in unsampled areas

```{r bei2}
# scale controls resolution
scale <- 50
dat$x <- scale * floor(dat$x / scale)
dat$y <- scale * floor(dat$y / scale)

dat <- dplyr::group_by(dat, x, y) %>%
  dplyr::summarise(n = n())

mesh <- make_mesh(
  dat,
  xy_cols = c("x", "y"),
  cutoff = 80 # min. distance between knots in X-Y units
)
# mesh$mesh$n # extract number of vertices/knots

# quick visualization of mesh
plot(mesh)
```

---

# Re-fitting the model  

Intercept only, 1 time slice  

```{r fit-model, echo=TRUE}
fit <- sdmTMB(
  n ~ 1,
  data = dat,
  mesh = mesh,
  family = truncated_nbinom2(link = "log"),
)
```

---

# Predict to grid  

* Slower, but include `se_fit = TRUE`
* Could also use `predict(..., nsim = 500)` and summarize matrix

```{r pred-fit, echo=TRUE, eval=TRUE}
# makes all combinations of x and y:
newdf <- expand.grid(
  x = seq(min(dat$x), max(dat$x), 5),
  y = seq(min(dat$y), max(dat$y), 5)
)
p <- predict(fit,
  newdata = newdf, se_fit = TRUE
)
```

---
 
# Visualizing uncertainty

* Why is uncertainty higher at vertices?  

```{r vis-vert}
ggplot() +
  inlabru::gg(mesh$mesh) +
  geom_point(data = p, aes(x = x, y = y, col = est_se)) +
  coord_equal()
```

---
 
# Predicting outside the survey domain

* Predict into border area

```{r pred-fit2, echo=FALSE, eval=TRUE}
# makes all combinations of x and y:
newdf <- expand.grid(
  x = seq(min(dat$x) - 100, max(dat$x) + 100, 5),
  y = seq(min(dat$y) - 100, max(dat$y) + 100, 5)
)
p <- predict(fit,
  newdata = newdf, se_fit = TRUE
)
ggplot() +
  inlabru::gg(mesh$mesh) + #<<
  geom_point(data = p, aes(x = x, y = y, col = est_se)) +
  coord_equal()
```
