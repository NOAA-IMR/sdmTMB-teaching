---
title: "Fitting spatial/spatiotemporal models and problem solving"
format: html
editor: visual
execute: 
  echo: true
  eval: true
---

```{r, message=FALSE, warning=FALSE}
library(sdmTMB)
library(dplyr)
library(ggplot2)
options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
theme_set(theme_light())
```

```{r}
d <- readRDS(here::here("dfo-tesa-2023/data/lingcod-qcs.rds"))
d <- add_utm_columns(d, units = "km", utm_crs = 32609)
```

```{r}
mesh <- make_mesh(d, c("X", "Y"), cutoff = 10)
plot(mesh)
```

```{r}
grid <- filter(qcs_grid, year == min(qcs_grid$year)) |> select(-year) |> 
  select(-depth_scaled, -depth_scaled2) |> 
  rename(depth_m = depth)
grid <- purrr::map_dfr(unique(d$year), ~ tibble(grid, year = .x))
```

```{r}
fit <- sdmTMB(
  catch_weight ~ 0 + as.factor(year),
  time = "year", # exercise
  spatial = "on", # exercise
  spatiotemporal = "iid", # exercise
  offset = log(d$area_swept),
  family = delta_gamma(), # exercise
  mesh = mesh, # exercise
  data = d,
  silent = FALSE,
  control = sdmTMBcontrol(newton_loops = 1)
)
```

```{r}
sanity(fit)
```

```{r}
fit
```

Is the range bigger or smaller for the binomial component than the Gamma component?

```{r}
set.seed(1)
resid <- residuals(fit) # exercise
```

How do the basic randomized quantile residuals look for the overall model?

```{r}
qqnorm(resid)
qqline(resid)
```

```{r}
pred <- predict(fit, newdata = grid, return_tmb_object = TRUE) # exercise
```

```{r}
ggplot(pred$data, aes(X, Y, fill = omega_s1)) + 
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = omega_s2)) + 
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = epsilon_st1)) + 
  geom_raster() +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = epsilon_st2)) + 
  geom_raster() +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = plogis(est1))) + 
  geom_raster() +
  facet_wrap(~year) +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = exp(est2))) + 
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_viridis_c(trans = "log10") +
  coord_fixed()
```

```{r}
ggplot(pred$data, aes(X, Y, fill = plogis(est1) * exp(est2))) + 
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_viridis_c(trans = "log10", option = "C") +
  coord_fixed()
```

```{r}
ind <- get_index(pred, area = 4, bias_correct = FALSE) # exercise
```

```{r}
ggplot(ind, aes(year, y = est, ymin = lwr, ymax = upr)) +
  geom_pointrange() +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05)))
```

# Problem solving

## Problem 1

```{r}
head(pcod)
```

```{r}
ggplot(pcod, aes(X, Y, size = density)) +
  geom_point(shape = 21)
```

```{r}
mesh <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 40)
plot(mesh)
```

```{r}
fit_pcod <- sdmTMB(
  density ~ poly(depth, 2),
  spatial = "on",
  family = tweedie(link = "log"),
  mesh = mesh,
  data = pcod
)
```

```{r}
sanity(fit_pcod)
fit_pcod
```

### Exercise:

1. What is the problem with the above?

Hint: look at `sanity(fit_pcod)`
Hint: look at the range estimate with `print(fit_pcod)`
Hint: look at the mesh `cutoff` value

2. Try fixing it below:

```{r}
mesh10 <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 10) # exercise
plot(mesh10)  # exercise
```

```{r}
fit_pcod10 <- sdmTMB(  # exercise
  density ~ poly(depth, 2),  # exercise
  spatial = "on",  # exercise
  family = tweedie(link = "log"),  # exercise
  mesh = mesh10,  # exercise
  data = pcod  # exercise
)  # exercise
```

```{r}
sanity(fit_pcod10)
fit_pcod10
```

## Problem 2

```{r}
d <- readRDS(here::here("dfo-tesa-2023/data/hbll-inside-yelloweye.rds"))
d_north <- dplyr::filter(d, survey == "HBLL INS N")
d_north <- add_utm_columns(d_north)
```

```{r}
ggplot(d_north, aes(X, Y, size = catch_count)) + 
  facet_wrap(~year) + 
  geom_point(shape = 21)
```

```{r}
mesh_north <- make_mesh(d_north, xy_cols = c("X", "Y"), cutoff = 5)
plot(mesh_north)
fit_ye <- sdmTMB(
  catch_count ~ 0 + as.factor(year),
  offset = log(d_north$hook_count),
  time = "year",
  spatial = "on",
  spatiotemporal = "iid",
  family = nbinom2(link = "log"),
  # silent = FALSE,
  mesh = mesh_north,
  data = d_north
)
```

```{r}
sanity(fit_ye)
```

### Exercise:

1. What is the problem with the above?
2. What are some ways you could attempt to fix this?
3. What is the simplest way you can fix this by changing the model structure? Try that below.

```{r}
fit_ye1 <- update(fit_ye, spatiotemporal = "off")  # exercise
sanity(fit_ye1)
fit_ye1
```

## Problem 3

```{r}
ggplot(pcod, aes(X, Y, colour = present)) +
  geom_point()
```

```{r}
mesh <- make_mesh(pcod, xy_cols = c("X", "Y"), cutoff = 10)
```

```{r}
dat <- filter(pcod, year == 2017)
```

```{r, eval=FALSE}
fit_pcod <- sdmTMB(
  present ~ poly(depth, 2),
  spatial = "on",
  family = binomial(),
  mesh = mesh,
  data = dat
)
```

### Exercise:

1. What is causing the error message?
2. Try to fix it below.

Hint: When was the mesh created relative to any filtering of the data? Why is this a problem?

```{r}
mesh <- make_mesh(dat, xy_cols = c("X", "Y"), cutoff = 10)  # exercise
fit_pcod <- sdmTMB(
  present ~ poly(depth, 2),
  spatial = "on",
  family = binomial(),
  mesh = mesh,
  data = dat
)
fit_pcod
```

Bonus: try plotting the depth effect using the `ggeffect::ggeffect()` function.

```{r}
ggeffects::ggeffect(fit_pcod, "depth [0:600 by=2]") |> plot()  # exercise
```
